/*
 * Implementation of ppack class - 23 nov 2020
 * statsgen method:  Compute statistis of a wordlist
 * maskgen methos:   Generate mask from the statistics generated by statsgen
 * policygen method: Generate a set of mask with some requirements
 *
 * Reimplementation PPACK class - 25 nov 2020
 * NO COMPLETED
 * --- Separate Base class of ppack.hhp in its own head file and its implementation file ---
 *
 * NO COMPLETED
 * --- Use pstruct class to manage the parameter of statsgen, maskgen and policygen ---
 *
 *
 * Maintainer: glozanoa <glozanoa@uni.pe>
*/


#ifndef __INCLUDE_STD_IOSTREAM_H__
#define __INCLUDE_STD_IOSTREAM_H__
#include<iostream>
#endif //__INCLUDE_STD_IOSTREAM_H_

#ifndef __INCLUDE_FSTREAM_H__
#define __INCLUDE_FSTREAM_H__
#include<fstream>
#endif //__INCLUDE_FSTREAM_H__

// #ifndef __INCLUDE_STD_STRING_H_
// #define __INCLUDE_STD_STRING_H_
// #include<string>
// #endif //__INCLUDE_STD_STRING_H_

#ifndef __INCLUDE_STD_VECTOR_H__
#define __INCLUDE_STD_VECTOR_H__
#include<vector>
#endif // __INCLUDE_STD_VECTOR_H__

using namespace std;




#ifndef __INCLUDE_BASE_H__
#define __INCLUDE_BASE_H__
#include "../include/basepoli.hpp"
#endif //__INCLUDE_BASE_H__


// #ifndef __INCLUDE_MASK_H_
// #define __INCLUDE_MASK_H_
// #include "../include/mask.hpp"
// #endif //__INCLUDE_MASK_H_

// #ifndef __INCLUDE_PPACK_H__
// #define __INCLUDE_PPACK_H__
// #include "../include/ppack.hpp"
// #endif //__INCLUDE_PPACK_H__


#ifndef __INCLUDE_LOGOS_H__
#define __INCLUDE_LOGOS_H__
#include "../include/logos.hpp"
#endif //__INCLUDE_LOGOS_H__


#ifndef __INCLUDE_COLOR_H__
#define __INCLUDE_COLOR_H__
#include "../include/color.hpp"
#endif //__INCLUDE_COLOR_H__


// #ifndef __INCLUDE_CSV_H__
// #define __INCLUDE_CSV_H__
// #include "../include/csv.hpp"
// #endif //__INCLUDE_CSV_H__



////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// Statsgen implementation  /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

// vector<Password>* passwdBlock(ifstream wordlist, int BLOCK)
// {
//   string passwd;
//   vector<Password> *vpasswd = new vector<Password>;
//   while((getline(wordlist, passwd) && passwd!="") && vpasswd->size() <= BLOCK)
//     {
//       vpasswd->push_back(passwd);
//     }

//   if(getline(wordlist, passwd) && passwd!="")
//     wordlist.close(); //closing wordlist file because it hasn't more passwords

//   return vpasswd;
// }


// void statsgen(string wordlist, string output,                           //IO parameters
//               bool hiderare, bool quiet,                      //print parameters
//               vector<string> charset,                            //password charset
//               int minlength, int maxlength)                         //length parameters
// {
//   ifstream wordlist_file(wordlist);
//   //string passwd;
//   int block_passwds=1000; // max block of pasword that i will read from wordlists
//   statstruct sstruct; //stats struct

//   while(wordlist_file.is_open()) // ensure that you close the wordlist when it hasn't more password
//     {
//       vector<Password> *vpasswd = passwdBlock(wordlist_file, block_passwds); // this function read at most 1000 passwords

// #pragma omp parallel for shared(vpasswd, sstruct)
//       for(int k=0; k<vpasswd->size(); k++)
//         {
//           Password passwd = vpasswd->at(k);

//           //length password stats
//           if(sstruct.length.find(passwd.size()) != sstruct.length.end())
//             {
//               #pragma omp critical
//               sstruct.length[passwd.size()] = 1;
//             }
//           else
//             {
//               #pragma omp atomic
//               sstruct.length[passwd.size()] += 1;
//             }

//           // Character set stats
//           if(sstruct.scs.find(passwd.scs()) != sstruct.scs.end())
//             {
//               #pragma omp critical
//               sstruct.scs[passwd.scs()] = 1;
//             }
//           else
//             {
//               #pragma omp atomic
//               sstruct.scs[passwd.scs()] += 1;
//             }


//           // advance mask stats
//           if(sstruct.mask.find(passwd.getMask()) != sstruct.mask.end())
//             {
//               #pragma omp critical
//               sstruct.mask[passwd.getMask()] = 1;
//             }
//           else{
//             #pragma omp atomic
//             sstruct.mask[passwd.getMask()] += 1;
//           }

//         }

//       // free vpasswd vector to read the other block of passwds
//       delete [] vpasswd;
//     }


//   statsgen_results(sstruct);

// }

// void statsgen_results(statstruct sstruct)
// {
//   // using sstuct struct write the output file and show the generated stats

//   cout << "Don't forget Implement statsgen_results" << endl;

// }


////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// maskgen implementation   /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////


// bool checkOccurence(int occurence, int minoccurence, int maxoccurence)
// {
//   if(occurence > minoccurence && occurence < maxoccurence)
//     return true;
//   return false;
// }

// bool satisfyFilter(Mask mask, int occurence, maskgenStruct mskgn)
// {
//   //Mask mask(mask_str);
//   if(checkLength(mask, mskgn.minlength, mskgn.maxlength) &&
//      //checkChartset(mask, mskgn.charsets) &&
//      checkOcurrence(occurence, mskgn.minoccurence, mskgn.maxoccurence) &&
//      checkComplexity(mask, mskgn.mincompexity, mskgn.maxcomplexity))
//     return true;
//   return false;
// }

// void maskgen(string statsgen_output, string output,    //IO parameters
//              bool show, bool quiet,                           //print parameters
//              vector<Mask> checkmasks,string checkmasksfile,       //checkmask parameters
//              vector<string> charset,                            //password charset
//              int minlength, int maxlength,                         //length parameters
//              int mincomplexity, int maxcomplexity,                 //complexity parameters
//              int minoccurrence, int maxoccurrence)                 //occurrence parameters
// {
//   CSVReader statsgen(statsgen_output);

//   maskgenStruct mskgn = init_maskgen_struct(minlength, maxlength,
//                                             mincomplexity, maxcomplexity,
//                                             minoccurrence, maxoccurrence,
//                                             charset);

//   // mask and occurence map
//   map<Mask, int> fmasks; //filtered masks (mask, occurence of mask)
//   vector<vector<string>> results = statsgen.getData(); //result of statsgen
// #pragma omp parallel for shared(statsgen_results)
//   for(int k=0; k < results.size(); k++)
//     {
//       // first element in statsgen output is mask and
//       // second element is occurence of the mask(first element)
//       Mask mask(results[k][0]);
//       int occurence = stoi(results[k][1]); //convert from string to interger

//       if(satisfyFilter(mask, occurence, mskgn))
//         {
//           fmasks[mask] = occurence;
//         }
//     }

//   if(!quiet)
//     {
//       string ppack_logo = Logo::random();
//       cout << ppack_logo << endl;
//     }

//   ofstream maskgen_output(output);
//   //maskgen_output.open();

//   if(show)
//     {

//       for(auto [mask, occurence] : fmasks)
//         {
//           maskgen_output << mask  <<  endl;

//           // print the mask and its occurence
//         }
//     }
//   else
//     {
//       for(auto [mask, occurence] : fmasks)
// 		maskgen_output << mask  <<  endl;

//     }
// }

void policygen(pstruct pargs)
{
  corePolicygen(pargs); //do almost all the work()

  if(pargs.quiet == false) // print the ppack logo
    {
      string ppack_logo = Logo::random();
      cout << ppack_logo << endl;
    }
  fine::print_status("Saving generated masks to [" + pargs.output +".hcmask]");
  fine::print_status("Using 8 OMP Threads.");

  // string password_policy =
  //   "Password policy:"  +\
  //   "\n\tPass Lengths:" + " min: " + minlength + " max: " + maxlength + \
  //   "\n\tMin strength:" + " l:" + minlower + " u:" + minupper + " d:" + mindigit + " s:" + minspecial +\
  //   "\n\tMin strength:" + " l:" + minlower + " u:" + minupper + " d:" + mindigit + " s:" + minspecial + "\n";

  //print_status("Policy Masks: ");

  if(pargs.show==true)
    {
      cout << "show generated masks" << endl;
    }

  fine::print_status("Policy Masks: ");
}
