  /*
 * Implementation of ppack class - 23 nov 2020
 * statsgen method:  Compute statistis of a wordlist
 * maskgen methos:   Generate mask from the statistics generated by statsgen
 * policygen method: Generate a set of mask with some requirements
 *
 * Reimplementation PPACK class - 25 nov 2020
 * COMPLETED: (27 nov 2020)
 * The base class is defined in include/basepoli.hpp
 * and implemented in src/basepoli.cpp
 * --- Separate Base class of ppack.hhp in its own head file and its implementation file ---
 *  
 *
 *
 * NO COMPLETED
 * --- Use pstruct class to manage the parameter of statsgen, maskgen and policygen ---
 *
 *
 * Maintainer: glozanoa <glozanoa@uni.pe>
*/



#ifndef __INCLUDE_PPACK_H__
#define __INCLUDE_PPACK_H__
#include "../include/ppack.hpp"
#include <cstdlib>
#include <exception>
#include <fstream>
#endif //__INCLUDE_PPACK_H__


//////////////////////////////////////////////
////////// statsgen  implementation   ////////
//////////////////////////////////////////////

bool sfilter(Password passwd, sstruct pargs)
{
  // add more complx filter
  if(Password::checkLength(passwd, pargs.minlength, pargs.maxlength))
    return true;
  return false;
}

vector<Password> passwdBlock(ifstream *wordlist, int block, sstruct pargs)
{
  string passwd;
  vector<Password> vpasswd;
  while((getline(*wordlist, passwd) && passwd!="") && vpasswd.size() <= block)
    {
      Password password(passwd);
      if(sfilter(passwd,  pargs))
        vpasswd.push_back(password);
    }

  getline(*wordlist, passwd);
  if(passwd=="")
    wordlist->close(); //closing wordlist file because it hasn't more passwords

  return vpasswd;
}

statstruct coreStatsgen(sstruct pargs)
{
  ifstream *wordlist  = new ifstream(pargs.wordlist);
  int block = 1000; // max block of pasword to read from wordlists
  statstruct stats; //stats of wordlists
  
  try{
    while(wordlist->is_open()) // ensure that you close the wordlist when it hasn't more password
    {
      //this function read at most 'block' filtered passwords. 
      vector<Password> vpasswd = passwdBlock(wordlist, block, pargs); 

      //#pragma omp parallel for shared(vpasswd, sstruct)
      for(int k=0; k<vpasswd.size(); k++)
        {
          Password passwd = vpasswd.at(k);

          //length password stats
          int passwdSize = passwd.size();
          if(stats.length.find(passwdSize) != stats.length.end())
              stats.length[passwdSize] += 1;
          else
              stats.length[passwdSize] = 1;
            
          // Character set stats
          SCS passwdSCS = passwd.getSCS();
          if(stats.scs.find(passwdSCS) != stats.scs.end())
              stats.scs[passwdSCS] += 1;
          else
              stats.scs[passwdSCS] = 1;


          // advance mask stats
          Mask passwdMask = passwd.getMask();
          if(stats.mask.find(passwdMask) != stats.mask.end())
              stats.mask[passwdMask] += 1;
          else
            stats.mask[passwdMask] = 1;
        }
    }
    return stats;
  }
  catch (std::exception& error)
  {
    cerr << error.what() << endl;
    wordlist->close();
    exit(EXIT_FAILURE);
  }
  
}

void PPACK::statsgen(sstruct pargs)
{
  // PRINT LOGO
  statstruct stats = coreStatsgen(pargs);
  
  cout << "PRINT ALL THE GENERATED STATSITCS." << endl;
  
  cout << "stats.scs:" << endl;
  for(auto [scs, occurence] : stats.scs)
    cout << scs << " : " << occurence << endl;

  cout << "stats.mask:" << endl;
  for(auto [mask, occurence] : stats.mask)
    cout << mask << " : " << occurence << endl;

  cout << "stats.length:" << endl;
  for(auto [length, occurence] : stats.length)
    cout << length << " : " << occurence << endl;

  cout << "PRINT ADITIONAL INFORMATION" << endl;
  
}


////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// maskgen implementation   /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////


// bool checkOccurence(int occurence, int minoccurence, int maxoccurence)
// {
//   if(occurence > minoccurence && occurence < maxoccurence)
//     return true;
//   return false;
// }

// bool satisfyFilter(Mask mask, int occurence, maskgenStruct mskgn)
// {
//   //Mask mask(mask_str);
//   if(checkLength(mask, mskgn.minlength, mskgn.maxlength) &&
//      //checkChartset(mask, mskgn.charsets) &&
//      checkOcurrence(occurence, mskgn.minoccurence, mskgn.maxoccurence) &&
//      checkComplexity(mask, mskgn.mincompexity, mskgn.maxcomplexity))
//     return true;
//   return false;
// }

// void maskgen(string statsgen_output, string output,    //IO parameters
//              bool show, bool quiet,                           //print parameters
//              vector<Mask> checkmasks,string checkmasksfile,       //checkmask parameters
//              vector<string> charset,                            //password charset
//              int minlength, int maxlength,                         //length parameters
//              int mincomplexity, int maxcomplexity,                 //complexity parameters
//              int minoccurrence, int maxoccurrence)                 //occurrence parameters
// {
//   CSVReader statsgen(statsgen_output);

//   maskgenStruct mskgn = init_maskgen_struct(minlength, maxlength,
//                                             mincomplexity, maxcomplexity,
//                                             minoccurrence, maxoccurrence,
//                                             charset);

//   // mask and occurence map
//   map<Mask, int> fmasks; //filtered masks (mask, occurence of mask)
//   vector<vector<string>> results = statsgen.getData(); //result of statsgen
// #pragma omp parallel for shared(statsgen_results)
//   for(int k=0; k < results.size(); k++)
//     {
//       // first element in statsgen output is mask and
//       // second element is occurence of the mask(first element)
//       Mask mask(results[k][0]);
//       int occurence = stoi(results[k][1]); //convert from string to interger

//       if(satisfyFilter(mask, occurence, mskgn))
//         {
//           fmasks[mask] = occurence;
//         }
//     }

//   if(!quiet)
//     {
//       string ppack_logo = Logo::random();
//       cout << ppack_logo << endl;
//     }

//   ofstream maskgen_output(output);
//   //maskgen_output.open();

//   if(show)
//     {

//       for(auto [mask, occurence] : fmasks)
//         {
//           maskgen_output << mask  <<  endl;

//           // print the mask and its occurence
//         }
//     }
//   else
//     {
//       for(auto [mask, occurence] : fmasks)
// 		maskgen_output << mask  <<  endl;

//     }
// }

namespace ppack{
  string VERSION = "1.0";
  int release = 1;
}

//////////////////////////////////////////////
////////// policygen implementation   ////////
//////////////////////////////////////////////

void PPACK::policygen(pstruct pargs)
{
  
  if(pargs.quiet == false) // print the ppack logo
    {
      //string ppack_logo = Logo::random();
      cout << "LOGO PPACK" << endl;
    }
  //fine::print_status("Saving generated masks to [" + pargs.output +".hcmask]");
  cout << "Saving generated masks to [" + pargs.output +".hcmask]" << endl;
  //fine::print_status("Using 8 OMP Threads.");

  corePolicygen(pargs); //do almost all the work()
}
