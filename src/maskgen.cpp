/*
 * maskgen - cli interface
 *
 * Depuration - 29 nov 2020
 * maskgen (cli interface) depurated.
 *
 * No tested functions: ALL FUNCTION TESTED
 *
 * No implemented functions:
 *  
 * NO COMPLETED
 * --- implement the input of parameters using a input file ---
 *
 * NO COMPLETED
 * --- Implement a beatiful output (call helper function  in maskgenWrite) ---
 *
 * NO COMPLETED
 * --- Implement mask writing in a file(call helper function  in maskgenWrite) ---
 *
 *
 *
 * Maintainer: glozanoa <glozanoa@uni.pe>
 *
 */

#ifndef __INCLUDE_STD_IOSTREAM_H__
#define __INCLUDE_STD_IOSTREAM_H__
#include <iostream>
#endif //__INCLUDE_STD_IOSTREAM_H__

#ifndef __INCLUDE_STD_VECTOR_H_
#define __INCLUDE_STD_VECTOR_H_
#include<vector>
#endif //__INCLUDE_STD_VECTOR_H_

using namespace std;

#ifndef __INCLUDE_PROGRAM_OPTIONS_H__
#define __INCLUDE_PROGRAM_OPTIONS_H__
#include<boost/program_options.hpp>
#endif //__INCLUDE_PROGRAM_OPTIONS_H__

//using namespace boost;
namespace po = boost::program_options;


#ifndef __INCLUDE_PPACK_H__
#define __INCLUDE_PPACK_H__
#include "../include/ppack.hpp"
#endif // __INCLUDE_PPACK_H__


// #ifndef __INCLUDE_LOGOS_H__
// #define __INCLUDE_LOGOS_H__
// #include "../include/logos.hpp"
// #endif //__INCLUDE_LOGOS_H__


#ifndef __INCLUDE_PSTRUCTS_H__
#define __INCLUDE_PSTRUCTS_H__
#include "../include/pstructs.hpp"
#endif //__INCLUDE_PSTRUCTS_H__




int main(int argc ,char* argv[])
{
    try
    {
        po::options_description files("Files I/O");
        files.add_options()
            ("statsgen, s", po::value<string>(), "File generated by statsgen.")
            ("output, o", po::value<string>()->default_value("maskgen.hcmasks"), "Ouput File.")
            ("input, i", po::value<string>()->default_value(""), "Input File.");

        po::options_description print("Print");
        print.add_options()
            ("show", po::value<bool>()->implicit_value(true)->default_value(false), "Show generated masks.")
            ("quiet, q", po::value<bool>()->implicit_value(true)->default_value(false), "Quiet printing(Omit PPACK logo).");

        po::options_description check("Compare mask o file of mask against an already cracked list.");
        check.add_options()
            //("checkmasks", po::value<vector<Mask>>(), "Masks to compare.")
            ("checkmasksfile", po::value<string>()->default_value(""), "File of mask to compare.");


        po::options_description password("Password Structure");
        password.add_options()
            //("scharset, scs", po::value<vector<SCS>>(), "Password's Simple Charset.")
            //("acharset, acs", po::value<vector<ACS>>(), "Password's Advance Charset.")
            ("minlength", po::value<unsigned int>()->default_value(0), "Minimum password length.")
            ("maxlength", po::value<int>()->default_value(-1), "Maximum password length.")
            ("mincomplexity", po::value<unsigned int>()->default_value(0), "Minimum password Complexity.")
            ("maxcomplexity", po::value<int>()->default_value(100), "Maximum password Complexity.");


        po::options_description frequency("Mask Ocurrence");
        frequency.add_options()
            ("minoccurrence", po::value<unsigned int>()->default_value(0), "Minimum of mask occurrences.")
            ("maxoccurrence", po::value<int>()->default_value(-1), "Maximum of mask occurrences.");


        po::options_description maskgen("Generate customized mask for crack passwords");
        maskgen.add_options()
            ("version, v", "PPACK version.")
            ("help, h", "Show help.");
        maskgen.add(files).add(print).add(check).add(password).add(frequency);

        po::variables_map vm;

        store(po::command_line_parser(argc, argv).
                options(maskgen).run(), vm);

        if(vm.count("help")){
            cout << maskgen << endl;
            return 1;
        }

        if(vm.count("version"))
        {
            //cout << "PPACK  version " + ppack::VERSION << endl;
            cout << "PPACK  version 0.1"  << endl;

            return 1;
        }

        mstruct pargs(vm);
        pargs.debug();

        PPACK::maskgen(pargs);
        return 0;
    }
    catch(std::exception& e)
    {
        cout << e.what() << endl;
        return 1;
    }
}
