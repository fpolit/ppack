#!/usr/bin/env python3

from sbash.core import Bash
import argparse
from fineprint.status import print_status, print_successful, print_failure
import re
import sys
import os
from os.path import basename
#from tabulate import tabulate

john_hashes=[
"descrypt",             "bsdicrypt",            "md5crypt",         "md5crypt-long",        "bcrypt",               "scrypt",    
"LM",                   "AFS",                  "tripcode",         "AndroidBackup",        "adxcrypt",             "agilekeychain",      
"aix-ssha1",            "aix-ssha256",          "aix-ssha512",      "andOTP",               "ansible",              "argon2",
"as400-des",            "as400-ssha1",          "asa-md5",          "AxCrypt",              "AzureAD",              "BestCrypt",        
"bfegg",                "Bitcoin",              "BitLocker",        "Bitwarden",            "BKS",  
"Blackberry-ES10",      "WoWSRP",               "Blockchain",       "chap",                 "Clipperz",             "cloudkeychain", 
"dynamic_n",            "CRC32",                "sha1crypt",        "sha256crypt",          "sha512crypt",          "Citrix_NS10", 
"dahua",                "dashlane",             "diskcryptor",      "Django",               "django-scrypt",        "dmd5", 
"dmg",                  "dominosec",            "dominosec8",       "DPAPImk",              "dragonfly3-32",        "dragonfly3-64", 
"dragonfly4-32",        "dragonfly4-64",        "Drupal7",          "eCryptfs",             "eigrp",                "electrum", 
"EncFS",                "enpass",               "EPI",              "EPiServer",            "ethereum",             "fde", 
"Fortigate256",         "Fortigate",            "FormSpring",       "FVDE",                 "geli",                 "gost", 
"gpg",                  "HAVAL-128-4",          "HAVAL-256-3",      "hdaa",                 "hMailServer",          "hsrp", 
"IKE",                  "ipb2",                 "itunes-backup",    "iwork",                "KeePass",              "keychain", 
"keyring",              "keystore",             "known_hosts",      "krb4",                 "krb5",                 "krb5asrep", 
"krb5pa-sha1",          "krb5tgs",              "krb5-17",          "krb5-18",              "krb5-3",               "kwallet", 
"lp",                   "lpcli",                "leet",             "lotus5",               "lotus85",              "LUKS", 
"MD2",                  "mdc2",                 "MediaWiki",        "monero",               "money",                "MongoDB", 
"scram",                "Mozilla",              "mscash",           "mscash2",              "MSCHAPv2",             "mschapv2-naive", 
"krb5pa-md5",           "mssql",                "mssql05",          "mssql12",              "multibit",             "mysqlna", 
"mysql-sha1",           "mysql",                "net-ah",           "nethalflm",            "netlm",                "netlmv2", 
"net-md5",              "netntlmv2",            "netntlm",          "netntlm-naive",        "net-sha1",             "nk",     
"notes",                "md5ns",                "nsec3",            "NT",                   "o10glogon",            "o3logon", 
"o5logon",              "ODF",                  "Office",           "oldoffice",            "OpenBSD-SoftRAID",     "openssl-enc", 
"oracle",               "oracle11",             "Oracle12C",        "osc",                  "ospf",                 "Padlock", 
"Palshop",              "Panama",               "PBKDF2-HMAC-MD4",  "PBKDF2-HMAC-MD5",      "PBKDF2-HMAC-SHA1",     "PBKDF2-HMAC-SHA256", 
"PBKDF2-HMAC-SHA512",   "PDF",                  "PEM",              "pfx",                  "pgpdisk",              "pgpsda", 
"pgpwde",               "phpass",               "PHPS",             "PHPS2",                "pix-md5",              "PKZIP", 
"po",                   "postgres",             "PST",              "PuTTY",                "pwsafe",               "qnx", 
"RACF",                 "RACF-KDFAES",          "radius",           "RAdmin",               "RAKP",                 "rar", 
"RAR5",                 "Raw-SHA512",           "Raw-Blake2",       "Raw-Keccak",           "Raw-Keccak-256",       "Raw-MD4", 
"Raw-MD5",              "Raw-MD5u",             "Raw-SHA1",         "Raw-SHA1-AxCrypt",     "Raw-SHA1-Linkedin",    "Raw-SHA224", 
"Raw-SHA256",           "Raw-SHA3",             "Raw-SHA384",       "ripemd-128",           "ripemd-160",           "rsvp", 
"Siemens-S7",           "Salted-SHA1",          "SSHA512",          "sapb",                 "sapg",                 "saph", 
"sappse",               "securezip",            "7z",               "Signal",               "SIP",                  "skein-256", 
"skein-512",            "skey",                 "SL3",              "Snefru-128",           "Snefru-256",           "LastPass", 
"SNMP",                 "solarwinds",           "SSH",              "sspr",                 "Stribog-256",          "Stribog-512", 
"STRIP",                "SunMD5",               "SybaseASE",        "Sybase-PROP",          "tacacs-plus",          "tcp-md5", 
"telegram",             "tezos",                "Tiger",            "tc_aes_xts",           "tc_ripemd160",         "tc_ripemd160boot", 
"tc_sha512",            "tc_whirlpool",         "vdi",              "OpenVMS",              "vmx",                  "VNC", 
"vtp",                  "wbb3",                 "whirlpool",        "whirlpool0",           "whirlpool1",           "wpapsk", 
"wpapsk-pmk",           "xmpp-scram",           "xsha",             "xsha512",              "ZIP",                  "ZipMonster", 
"plaintext",            "has-160",              "HMAC-MD5",         "HMAC-SHA1",            "HMAC-SHA224",          "HMAC-SHA256", 
"HMAC-SHA384",          "HMAC-SHA512",          "dummy",            "crypt",                "cq"
]   


class MaskAttack:
    """
        This class perform a mask attack
    """
    hashFormat = john_hashes
    
    def __init__(self, masksFile, hashType, hashFile):
        self.masksFile = masksFile
        self.hashType = hashType
        self.hashFile = hashFile
        
    @staticmethod
    def searchHash(search=None, *, sensitive=False):
        if search:
            if not sensitive:
                hashPattern = re.compile(rf"\w*{search}\w*", re.IGNORECASE)
            else:
                hashPattern = re.compile(rf"\w*{search}\w*")
                
            print_status("Posible hashes format:")
            for hashFormat in MaskAttack.hashFormat:
                if hashPattern.search(hashFormat):
                    print_successful(hashFormat)

        else:
            print_failure("No pattern given.")


    def run(self, ompThreads=None, mpiProc=None, partition="me"):
        try:
            if ompThreads and mpiProc:
                raise Exception("No hybrid execution supported")
            elif ompThreads and not mpiProc: # omp execution
                Bash.exec(f"export OMP_NUM_THREADS={ompThreads}")
                masks = open(self.masksFile, 'r')
                while mask := masks.readline():
                    mask = mask.rstrip()
                    attack_cmd = f"john --mask={mask} --format={self.hashType} {self.hashFile}"
                    print()
                    print_status(f"Running {attack_cmd}")
                    Bash.exec(attack_cmd)
            elif mpiProc and not ompThreads: # mpi execution
                if partition == "me":
                    masks = open(self.masksFile, 'r')
                    while mask := masks.readline():
                        mask = mask.rstrip()
                        attack_cmd = f"mpirun -n {mpiProc} john --mask={mask} --format={hashType} {hashFile}"
                        print()
                        print_status(f"Running {attack_cmd}")
                        Bash.exec(attack_cmd)
                else: # write a slurm script and run in a cluster
                    try:
                        slurm_script = f"""
                        #!/bin/bash
                        #SBATCH --job-name=maskAttack
                        #SBATCH --
                        """
                        nameHashFile = basename(self.hashFile)
                        slurm = open(f"{nameHashFile}.slurm", 'w')
                        slurm.write(slurm_script)
                        slurm.close()

                        Bash.exec(f"sbash {nameHashFile}.slurm")
                    except Exception as error:
                        print_failure(error)
                        sys.exit(1)

            else:
                raise Exception("No OpenMP or MPI execution seleted.")

        except Exception as error:
            print_failure(error)
            sys.exit(1)

if __name__=="__main__":
    parser = argparse.ArgumentParser(description="Mask Attack", prog='mattack', usage='%(prog)s [-h] [-m MASKS] [-f HASH_TYPE] hash')
    
    parser.add_argument('-m', '--masks',
                        help='Mask File to perform Mask Attack')

    parser.add_argument('-f', '--format', choices=john_hashes,
                        help='John The Ripper\'s  hash format')

    parser.add_argument('-n', '--nproc', type=int, default=0,
                        help='Number of proccessors')

    parser.add_argument('-t', '--threads', type=int, default=0,
                        help='Number of OMP threads')

    parser.add_argument('-p', '--partition', type=str, default="me",
                        help='Slurm Partition')
    
    parser.add_argument('-s', '--search',
                        help='Search by a hash format')
    
    parser.add_argument('hashes',
                        help='hashes file to crack')
    

    args = parser.parse_args()
    
    if searchHash := args.search:
        MaskAttack.searchHash(searchHash)
    else:
        masksFile = args.masks
        hashType = args.format
        hashFile = args.hash
        mattack = MaskAttack(masksFile, hashType, hashFile)

        nproc = args.nproc
        threads = args.threads
        partition = args.partition
        mattack.run(threads, nproc, partition)